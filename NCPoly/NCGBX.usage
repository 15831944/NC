(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2016-10-30 14:40:49.611972                       *
 *************************************************************************)


(* GetMonomialOrder *)
GetMonomialOrder::usage = "\
GetMonomialOrder[] returns the current monomial ordering in the form of a list.

For example

    SetMonomialOrder[{a,b}, {c}, {d}]
    order = GetMonomialOrder[]

returns

    order = {{a,b},{c},{d}}

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";

(* NCPolyToNC *)
NCPolyToNC::usage = "\
NCPolyToNC[poly, vars] constructs an nc expression from the noncommutative polynomial object poly in variables vars. Monomials are specified in terms of the symbols in the list var.

For example

    poly = NCToNCPoly[x**y - 2 y**z, {x, y, z}];
    expr = NCPolyToNC[poly, {x, y, z}];

returns

    expr = x**y - 2 y**z

See also: NCPolyToNC, NCPoly.";

(* SetMonomialOrder *)
SetMonomialOrder::usage = "\
SetMonomialOrder[var1, var2, ...] sets the current monomial order.

For example

    SetMonomialOrder[a,b,c]

sets the lex order a ≪ b ≪ c.

If one uses a list of variables rather than a single variable as one of the arguments, then multigraded lex order is used. For example

    SetMonomialOrder[{a,b,c}]

sets the graded lex order a < b < c.

Another example:

    SetMonomialOrder[{{a, b}, {c}}]

or

    SetMonomialOrder[{a, b}, c]

set the multigraded lex order a < b ≪ c.

Finally

    SetMonomialOrder[{a,b}, {c}, {d}]

or

    SetMonomialOrder[{a,b}, c, d]

is equivalent to the following two commands

    SetKnowns[a,b] 
    SetUnknowns[c,d]

There is also an older syntax which is still supported:

    SetMonomialOrder[{a, b, c}, n]

sets the order of monomials to be a < b < c and assigns them grading level n.

    SetMonomialOrder[{a, b, c}, 1]

is equivalent to SetMonomialOrder[{a, b, c}]. When using this older syntax the user is responsible for calling ClearMonomialOrder to make sure that the current order is empty before starting.

See also: ClearMonomialOrder, GetMonomialOrder, PrintMonomialOrder, SetKnowns, SetUnknowns.";

(* SetUnknowns *)
SetUnknowns::usage = "\
SetUnknowns[var1, var2, ...] records the variables var1, var2, ... to be corresponding to unknown quantities.

SetUnknowns and SetKnowns prescribe a monomial order with the knowns at the the bottom and the unknowns at the top.

For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]

is equivalent to

    SetMonomialOrder[{a,b}, {c}, {d}]

which corresponds to the order a < b ≪ c ≪ d and

    SetKnowns[a,b] 
    SetUnknowns[{c,d}]

is equivalent to

    SetMonomialOrder[{a,b}, {c, d}]

which corresponds to the order a < b ≪ c < d.

Note that SetKnowns flattens grading so that

    SetKnowns[a,b] 

and

    SetKnowns[{a},{b}] 

result both in the order a < b.

Successive calls to SetUnknowns and SetKnowns overwrite the previous knowns and unknowns. For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]
    SetKnowns[c,d]
    SetUnknowns[a,b]

results in an ordering c < d ≪ a ≪ b.

See also: SetKnowns, SetMonomialOrder.";

(* SetKnowns *)
SetKnowns::usage = "\
SetKnowns[var1, var2, ...] records the variables var1, var2, ... to be corresponding to known quantities.

SetUnknowns and Setknowns prescribe a monomial order with the knowns at the the bottom and the unknowns at the top.

For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]

is equivalent to

    SetMonomialOrder[{a,b}, {c}, {d}]

which corresponds to the order a < b ≪ c ≪ d and

    SetKnowns[a,b] 
    SetUnknowns[{c,d}]

is equivalent to

    SetMonomialOrder[{a,b}, {c, d}]

which corresponds to the order a < b ≪ c < d.

Note that SetKnowns flattens grading so that

    SetKnowns[a,b] 

and

    SetKnowns[{a},{b}] 

result both in the order a < b.

Successive calls to SetUnknowns and SetKnowns overwrite the previous knowns and unknowns. For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]
    SetKnowns[c,d]
    SetUnknowns[a,b]

results in an ordering c < d ≪ a ≪ b.

See also: SetUnknowns, SetMonomialOrder.";

(* NCRuleToPoly *)
NCRuleToPoly::usage = "\
";

(* NCMakeGB *)
NCMakeGB::usage = "\
NCMakeGB[{poly1, poly2, ...}, k] attempts to produces a nc Gröbner Basis (GB) associated with the list of nc polynomials {poly1, poly2, ...}. The GB algorithm proceeds through _at most_ k iterations until a Gröbner basis is found for the given list of polynomials with respect to the order imposed by SetMonomialOrder.

If NCMakeGB terminates before finding a GB the message NCMakeGB::Interrupted is issued.

The output of NCMakeGB is a list of rules with left side of the rule being the _leading_ monomial of the polynomials in the GB.

For example:

    SetMonomialOrder[x];
    gb = NCMakeGB[{x^2 - 1, x^3 - 1}, 20]

returns

    gb = {x -> 1}

that corresponds to the polynomial x − 1, which is the nc Gröbner basis for the ideal generated by x² − 1 and x³ − 1.

NCMakeGB[{poly1, poly2, ...}, k, options] uses options.

The following options can be given:

-   SimplifyObstructions (True): control whether obstructions are simplified before being added to the list of active obstructions;
-   SortObstructions (False): control whether obstructions are sorted before being processed;
-   SortBasis (False): control whether initial basis is sorted before initiating algorithm;
-   VerboseLevel (1): control level of verbosity from 0 (no messages) to 5 (very verbose);
-   PrintBasis (False): if True prints current basis at each major iteration;
-   PrintObstructions (False): if True prints current list of obstructions at each major iteration;
-   PrintSPolynomials (False): if True prints every S-polynomial formed at each minor iteration.

NCMakeGB makes use of the algorithm NCPolyGroebner implemented in NCPolyGroeber.

See also: ClearMonomialOrder, GetMonomialOrder, PrintMonomialOrder, SetKnowns, SetUnknowns, NCPolyGroebner.";

(* ClearMonomialOrder *)
ClearMonomialOrder::usage = "\
ClearMonomialOrder[] clear the current monomial ordering.

It is only necessary to use ClearMonomialOrder if using the indexed version of SetMonomialOrder.

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";

(* NCToNCPoly *)
NCToNCPoly::usage = "\
NCToNCPoly[expr, var] constructs a noncommutative polynomial object in variables var from the nc expression expr.

For example

    NCToNCPoly[x**y - 2 y**z, {x, y, z}] 

constructs an object associated with the noncommutative polynomial xy − 2yz in variables x, y and z. The internal representation is so that the terms are sorted according to a degree-lexicographic order in vars. In the above example, x < y < z.";

(* PrintMonomialOrder *)
PrintMonomialOrder::usage = "\
PrintMonomialOrder[] prints the current monomial ordering.

For example

    SetMonomialOrder[{a,b}, {c}, {d}]
    PrintMonomialOrder[]

print a < b ≪ c ≪ d.

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";
