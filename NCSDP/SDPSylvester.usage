(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2017-04-17 14:02:49.517561                       *
 *************************************************************************)


(* SDPDualEval *)
SDPDualEval::usage = "\
SDPDualEval[A, X] evaluates the linear function A*X = {b₁Xa₁, ⋯, bnXan} in an SDPSylvester.

For example

See also: SDPEval, SDPSolve, SDPMatrices.";

(* SDPEval *)
SDPEval::usage = "\
SDPEval[A, y] evaluates the linear function $A y = \\frac{1}{2} \\sum_i a_i y_i b_i + (a_i y_i b_i)^T$ in an SDPSylvester.

For example

See also: SDPDualEval, SDPSolve, SDPMatrices.";

(* SDPSolve *)
SDPSolve::usage = "\
SDPSolve[{A,b,c}] solves an SDP in the form:
$$
\\begin{aligned}
  \\max_{y, S} \\quad & \\sum_i \\operatorname{trace}(b_i^T y_i) \\\\
  \\text{s.t.} \\quad & A y + S = \\frac{1}{2} \\sum_i a_i y_i b_i + (a_i y_i b_i)^T + S = C \\\\
                    & S \\succeq 0
\\end{aligned}
$$
 SDPSolve returns a list with four entries:

-   The first is the primal solution y;
-   The second is the dual solution X;
-   The third is the primal slack variable S;
-   The fourth is a list of flags:
    -   PrimalFeasible: True if primal problem is feasible;
    -   FeasibilityRadius: less than one if primal problem is feasible;
    -   PrimalFeasibilityMargin: close to zero if primal problem is feasible;
    -   DualFeasible: True if dual problem is feasible;
    -   DualFeasibilityRadius: close to zero if dual problem is feasible.

For example:

    {Y, X, S, flags} = SDPSolve[abc]

solves the SDP abc.

SDPSolve[{A,b,c}, options] uses options.

options are those of PrimalDual.

The easiest way to create parameters abc to be solved by SDPSolve is using NCSDP.

See also: NCSDP.";
