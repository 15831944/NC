(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2016-09-26 14:58:22.531825                       *
 *************************************************************************)


(* NCMatrixDescriptorRealization *)
NCMatrixDescriptorRealization::usage = "\
NCMatrixDescriptorRealization[RationalMatrix,UnknownVariables] is similar to NCDescriptorRealization except it takes a _Matrix_ with rational function entries and returns a matrix of lists of the vectors/matrix {C,G,B}. A different {C,G,B} for each entry.";

(* SignatureOfAffineTerm *)
SignatureOfAffineTerm::usage = "\
SignatureOfAffineTerm[Pencil,Unknowns] returns a list of the number of positive, negative and zero eigenvalues in the affine part of Pencil.";

(* PinnedQ *)
PinnedQ::usage = "\
PinnedQ[Pencil_,Unknowns_] is True or False.";

(* NCSymmetricDeterminantalRepresentationDirect *)
NCSymmetricDeterminantalRepresentationDirect::usage = "\
NCSymmetricDeterminantalRepresentationDirect[SymmetricPolynomial,Unknowns] returns a linear pencil matrix whose determinant equals Constant * CommuteEverything[SymmetricPolynomial]. This uses the direct algorithm: Find a realization of 1 - NCSymmetricPolynomial,...";

(* NCSymmetricDeterminantalRepresentationReciprocal *)
NCSymmetricDeterminantalRepresentationReciprocal::usage = "\
NCSymmetricDeterminantalRepresentationReciprocal[SymmetricPolynomial,Unknowns] returns a linear pencil matrix whose determinant equals Constant * CommuteEverything[NCSymmetricPolynomial]. This uses the reciprocal algorithm: find a symmetric minimal descriptor realization of inv[NCSymmetricPolynomial], so NCSymmetricPolynomial must be nonzero at the origin.";

(* NonCommutativeLift *)
NonCommutativeLift::usage = "\
NonCommutativeLift[Rational] returns a noncommutative symmetric lift of Rational.";

(* NCSymmetricDescriptorRealization *)
NCSymmetricDescriptorRealization::usage = "\
NCSymmetricDescriptorRealization[RationalSymmetricFunction, Unknowns] combines two steps: NCSymmetrizeMinimalDescriptorRealization[NCMinimalDescriptorRealization[RationalSymmetricFunction, Unknowns]].";

(* TestDescriptorRealization *)
TestDescriptorRealization::usage = "\
TestDescriptorRealization[Rat,{C,G,B},Unknowns] checks if Rat equals CG−1B by substituting random 2-by-2 matrices in for the unknowns. TestDescriptorRealization[Rat,{C,G,B},Unknowns,NumberOfTests] can be used to specify the NumberOfTests, the default being 5.";

(* NCSymmetrizeMinimalDescriptorRealization *)
NCSymmetrizeMinimalDescriptorRealization::usage = "\
NCSymmetrizeMinimalDescriptorRealization[{C,G,B},Unknowns] symmetrizes the minimal realization {C,G,B} (such as output from NCMinimalRealization) and outputs {Ctilda,Gtilda} corresponding to the realization {Ctilda, Gtilda,Transpose[Ctilda]}.

WARNING: May produces errors if the realization doesn't correspond to a symmetric rational function.";

(* NCMinimalDescriptorRealization *)
NCMinimalDescriptorRealization::usage = "\
NCMinimalDescriptorRealization[RationalFunction,UnknownVariables] returns {C,G,B} where MatMult[C,NCInverse[G],B] == RationalFunction, G is linear in the UnknownVariables, and the realization is minimal (may be pinned).";

(* NCDeterminantalRepresentationReciprocal *)
NCDeterminantalRepresentationReciprocal::usage = "\
NCDeterminantalRepresentationReciprocal[Polynomial,Unknowns] returns a linear pencil matrix whose determinant equals Constant * CommuteEverything[Polynomial]. This uses the reciprocal algorithm: find a minimal descriptor realization of inv[Polynomial], so Polynomial must be nonzero at the origin.";

(* NCDescriptorRealization *)
NCDescriptorRealization::usage = "\
NCDescriptorRealization[RationalExpression,UnknownVariables] returns a list of 3 matrices {C,G,B} such that CG−1B is the given RationalExpression. i.e. MatMult[C,NCInverse[G],B] === RationalExpression.

C and B do not contain any UnknownsVariables and G has linear entries in the UnknownVariables.";
